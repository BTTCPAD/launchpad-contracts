{
  "language": "Solidity",
  "sources": {
    "contracts/BttcPadSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"./ISalesFactory.sol\";\nimport \"./IAllocationStaking.sol\";\n\ninterface IERC20Extented is IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ncontract BttcPadSale {\n\n    using SafeERC20 for IERC20Extented;\n\n    IAllocationStaking public allocationStakingContract;\n    ISalesFactory public factory;\n    IERC20Extented public USDCToken = IERC20Extented(0xC0e296da19bBdcf960291C7AEf02c9F24D6fA1fd);\n    \n    struct Sale {\n        IERC20Extented token;\n        bool isCreated;\n        bool earningsWithdrawn;\n        bool leftoverWithdrawn;\n        address saleOwner;\n        uint256 tokenPriceInUSDC;\n        uint256 amountOfTokensToSell;\n        uint256 totalUSDCRaised;\n        uint256 saleEnd;\n        uint256 saleStart;\n        uint256 tokensUnlockTime;\n        uint256 minimumTokenDeposit;\n    }\n\n    struct Participation {\n        uint256 amountPaid;\n        uint256 timeParticipated;\n        uint256 tierId;\n        bool isTokenLeftWithdrawn;\n        bool[] isPortionWithdrawn;\n    }\n\n    struct Tier {\n        uint256 participants;\n        uint256 tierWeight; \n        uint256 USDCDeposited;\n        uint256 minToStake;\n        uint256 maxToStake;\n    }\n\n    struct WhitelistUser {\n        address userAddress;\n        uint256 userTierId;\n    }\n\n    struct Registration {\n        uint256 registrationTimeStarts;\n        uint256 registrationTimeEnds;\n        uint256 numberOfRegistrants;\n    }\n\n    Sale public sale;\n    Registration public registration;\n\n    address public admin;\n\n    bool tokensDeposited;\n    uint256 public numberOfParticipants;\n    mapping(address => Participation) public userToParticipation;\n    mapping(address => uint256) public addressToRoundRegisteredFor;\n    mapping(address => bool) public isParticipated;\n    mapping(address => WhitelistUser) public Whitelist;\n\n    uint256[] public vestingPortionsUnlockTime;\n    uint256[] public vestingPercentPerPortion;\n\n    Tier[] public tierIdToTier;\n    uint256 public totalTierWeight;\n\n    modifier onlySaleOwner() {\n        require(msg.sender == sale.saleOwner, \"OnlySaleOwner\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(\n            msg.sender == admin ,\n            \"Only admin can call this function.\"\n        );\n        _;\n    }\n\n\n    constructor(\n        address _admin, \n        address _allocationStaking)  {\n            require(_admin != address(0));\n            require(_allocationStaking != address(0));\n            admin = _admin;\n            factory = ISalesFactory(msg.sender);\n            allocationStakingContract = IAllocationStaking(_allocationStaking);\n    }\n\n    function setVestingParams(\n        uint256[] memory _unlockingTimes,\n        uint256[] memory _percents\n    ) external onlyAdmin {\n        require(\n            vestingPercentPerPortion.length == 0 &&\n            vestingPortionsUnlockTime.length == 0\n        );\n        require(_unlockingTimes.length == _percents.length);\n        require(sale.isCreated, \"Safeguard for making sure setSaleParams get first called.\");\n\n        uint256 sum;\n\n        for (uint256 i = 0; i < _unlockingTimes.length; i++) {\n            vestingPortionsUnlockTime.push(_unlockingTimes[i]);\n            vestingPercentPerPortion.push(_percents[i]);\n            sum += _percents[i];\n        }\n\n        require(sum == 100, \"Percent distribution issue.\");\n    }\n\n    function setSaleParams(\n        address _token,\n        address _saleOwner,\n        uint256 _tokenPriceInUSDC,\n        uint256 _amountOfTokensToSell,\n        uint256 _saleStart,\n        uint256 _saleEnd,\n        uint256 _tokensUnlockTime,\n        uint256 _minimumTokenDeposit\n    ) external onlyAdmin {\n        require(!sale.isCreated, \"Sale created.\");\n        require(\n            _saleOwner != address(0),\n            \"owner can`t be 0.\"\n        );\n        require(\n            _tokenPriceInUSDC != 0 &&\n                _amountOfTokensToSell != 0 &&\n                _saleEnd > block.timestamp &&\n                _tokensUnlockTime > block.timestamp,\n            \"Bad input\"\n        );\n        sale.token = IERC20Extented(_token);\n        sale.isCreated = true;\n        sale.saleOwner = _saleOwner;\n        sale.tokenPriceInUSDC = _tokenPriceInUSDC;\n        sale.amountOfTokensToSell = _amountOfTokensToSell;\n        sale.saleEnd = _saleEnd;\n        sale.saleStart = _saleStart;\n        sale.tokensUnlockTime = _tokensUnlockTime;\n        sale.minimumTokenDeposit = _minimumTokenDeposit;\n    }\n\n    function setRegistrationTime(\n        uint256 _registrationTimeStarts,\n        uint256 _registrationTimeEnds\n    ) external onlyAdmin {\n        require(sale.isCreated, \"1\");\n        require(\n            _registrationTimeStarts >= block.timestamp &&\n                _registrationTimeEnds > _registrationTimeStarts, \"3\"\n        );\n        require(_registrationTimeEnds < sale.saleEnd, \"4\");\n\n\n        registration.registrationTimeStarts = _registrationTimeStarts;\n        registration.registrationTimeEnds = _registrationTimeEnds;\n\n    }\n\n    function registerForSale() public {\n\n        uint256 stakeAmount = allocationStakingContract.deposited(msg.sender);\n\n        require(tierIdToTier.length > 0, \"Need to set Tiers\");\n        require(tierIdToTier[0].minToStake <= stakeAmount / 1e18 , \"Need to stake minimum for current sale\");\n        require( Whitelist[msg.sender].userAddress != msg.sender, \"You are registered\");\n        require( block.timestamp >= registration.registrationTimeStarts && block.timestamp <= registration.registrationTimeEnds , \"Register is closed\");\n        for (uint256 i = 0; i < tierIdToTier.length; i++) {\n            Tier memory t = tierIdToTier[i];\n            if( t.minToStake <= stakeAmount && t.maxToStake > stakeAmount){\n                WhitelistUser memory u = WhitelistUser({\n                    userAddress: msg.sender, \n                    userTierId: i\n                });\n                Whitelist[msg.sender] = u;\n                registration.numberOfRegistrants++;\n                break;\n            }\n        }\n    }\n    \n    function updateTokenPriceInUSDC(uint256 price) external onlyAdmin {\n        require(price > 0, \"Price == 0.\");\n        require(sale.saleStart > block.timestamp, \"Sale started\");\n        sale.tokenPriceInUSDC = price;\n    }\n\n    function setWhitelistUsers(address [] calldata users, uint256 tierId) public payable onlyAdmin {\n         for (uint256 i = 0; i < users.length; i++) {\n            WhitelistUser memory u = WhitelistUser({\n                userAddress: users[i], \n                userTierId: tierId\n            });\n            Whitelist[users[i]] = u;\n        }\n        \n    }\n\n    function addTiers(uint256 [] calldata tierWeights, uint256 [] calldata tierPoints)  public onlyAdmin {   \n        \n        require(tierWeights.length > 0, \"Need 1 tier\");\n        require(tierWeights.length == tierPoints.length, \"nedd same length\");\n\n\n        for (uint256 i = 0; i < tierWeights.length; i++) {\n            require( \n                tierWeights[i] > 0,\n                \"weight > 0\"\n            );\n\n            totalTierWeight = totalTierWeight + tierWeights[i];\n\n            uint256 maxToStake = tierPoints.length - 1 > i ? tierPoints[i+1] : 2**256 - 1;\n\n            Tier memory t = Tier({\n                participants: 0,\n                tierWeight: tierWeights[i],\n                USDCDeposited: 0,\n                minToStake: tierPoints[i],\n                maxToStake: maxToStake\n            });\n            tierIdToTier.push(t);\n        }\n\n     \n    }\n\n\n    function depositTokens() external onlySaleOwner  {\n        require(\n            !tokensDeposited, \"Deposit only once\"\n        );\n        tokensDeposited = true;\n        sale.token.safeTransferFrom(\n            msg.sender,\n            address(this),\n            sale.amountOfTokensToSell\n        );\n    }\n\n    function participate(uint256 amount) \n    external \n    payable \n    {\n        require(sale.isCreated, \"Wait sale create\");\n\n        require( block.timestamp >= sale.saleStart && block.timestamp <= sale.saleEnd , \"Sale not active\");\n\n        require(!isParticipated[msg.sender], \"participate only once.\");\n\n        require(msg.sender == tx.origin, \"Only direct calls\");\n\n\n        require(amount > 0, \"Can't buy 0 tokens\");\n\n        require((amount / (10 ** USDCToken.decimals())) % 2 == 0, \"Amount need to be divide by 2\");\n\n        require( Whitelist[msg.sender].userAddress != address(0), \"User must be in white list\" );\n\n        require(amount >= sale.minimumTokenDeposit, \"Can't deposit less than minimum\"  );\n\n        uint256 _tierId = Whitelist[msg.sender].userTierId;\n        sale.totalUSDCRaised = sale.totalUSDCRaised + amount;\n\n        bool[] memory _isPortionWithdrawn = new bool[](\n            vestingPortionsUnlockTime.length\n        );\n\n        Participation memory p = Participation({\n            amountPaid: amount,\n            timeParticipated: block.timestamp,\n            tierId: _tierId,\n            isTokenLeftWithdrawn: false,\n            isPortionWithdrawn: _isPortionWithdrawn\n        });\n\n        Tier storage t = tierIdToTier[_tierId];\n\n        t.participants = t.participants + 1;\n        t.USDCDeposited = t.USDCDeposited + amount;\n        userToParticipation[msg.sender] = p;\n        isParticipated[msg.sender] = true;\n        numberOfParticipants++;\n\n        USDCToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdrawTokens(uint256 portionId) external {\n        require(\n            block.timestamp >= sale.tokensUnlockTime,\n            \"Tokens cann`t be withdrawn.\"\n        );\n        require(portionId < vestingPercentPerPortion.length);\n\n        Participation storage p = userToParticipation[msg.sender];\n\n        if(!p.isTokenLeftWithdrawn){\n            withdrawLeftoverForUser(msg.sender);\n            p.isTokenLeftWithdrawn = true;\n        }\n\n        if (\n            !p.isPortionWithdrawn[portionId] &&\n            vestingPortionsUnlockTime[portionId] <= block.timestamp\n        ) {\n            p.isPortionWithdrawn[portionId] = true;\n            uint256 amountWithdrawing = calculateAmountWithdrawing(msg.sender, vestingPercentPerPortion[portionId]);\n\n            if(amountWithdrawing > 0) {\n                sale.token.safeTransfer(msg.sender, amountWithdrawing);\n            }\n        } else {\n            revert(\"Tokens withdrawn or portion not unlocked.\");\n        }\n    }\n\n    function withdrawLeftoverForUser(address userAddress) internal  {\n        Participation memory p = userToParticipation[userAddress];\n\n\n        uint256 tokensForUser = calculateAmountWithdrawing(userAddress, 100);\n\n        uint256 leftover = p.amountPaid - tokensForUser * sale.tokenPriceInUSDC / 10**sale.token.decimals();\n\n        if(leftover > 0){\n            USDCToken.safeTransfer(msg.sender, leftover);\n        }\n    }\n    \n\n    function withdrawMultiplePortions(uint256 [] calldata portionIds) external {\n        uint256 totalToWithdraw = 0;\n\n        Participation storage p = userToParticipation[msg.sender];\n\n        if(!p.isTokenLeftWithdrawn){\n            withdrawLeftoverForUser(msg.sender);\n            p.isTokenLeftWithdrawn = true;\n        }\n\n        for(uint i=0; i < portionIds.length; i++) {\n            uint256 portionId = portionIds[i];\n            require(portionId < vestingPercentPerPortion.length);\n\n            if (\n                !p.isPortionWithdrawn[portionId] &&\n                vestingPortionsUnlockTime[portionId] <= block.timestamp\n            ) {\n                p.isPortionWithdrawn[portionId] = true;\n                uint256 amountWithdrawing = calculateAmountWithdrawing(msg.sender, vestingPercentPerPortion[portionId]);\n                totalToWithdraw = totalToWithdraw + amountWithdrawing;\n            }\n        }\n\n        if(totalToWithdraw > 0) {\n            sale.token.safeTransfer(msg.sender, totalToWithdraw);\n        }\n    }\n\n    function withdrawEarnings() external onlySaleOwner {\n        withdrawEarningsInternal();\n    }\n\n    function withdrawLeftover() external onlySaleOwner {\n        withdrawLeftoverInternal();\n    }\n\n\n    function withdrawEarningsInternal() internal  {\n        require(block.timestamp >= sale.saleEnd);\n        require(!sale.earningsWithdrawn);\n        sale.earningsWithdrawn = true;\n        uint256 totalProfit = sale.totalUSDCRaised;\n        USDCToken.safeTransfer(msg.sender, totalProfit);\n    }\n\n    function withdrawLeftoverInternal() internal {\n        require(block.timestamp >= sale.saleEnd);\n        require(!sale.leftoverWithdrawn);\n        sale.leftoverWithdrawn = true;\n        uint256 totalTokensSold = calculateTotalTokensSold();\n        uint256 leftover = sale.amountOfTokensToSell - totalTokensSold;\n        if (leftover > 0) {\n            sale.token.safeTransfer(msg.sender, leftover);\n        }\n    }\n\n    function calculateTotalTokensSold() internal view returns (\n            uint256\n        ) {\n        uint256 totalTokensSold = 0;\n\n        for (uint256 i = 0; i < tierIdToTier.length; i++) {\n            Tier memory t = tierIdToTier[i];\n\n            uint256 tokensPerTier = t.tierWeight * sale.amountOfTokensToSell/totalTierWeight;\n\n            if( tokensPerTier * sale.tokenPriceInUSDC / 10**sale.token.decimals() <= t.USDCDeposited ){\n                totalTokensSold = totalTokensSold + tokensPerTier;\n            } else {\n                totalTokensSold =  totalTokensSold + t.USDCDeposited / sale.tokenPriceInUSDC * 10**sale.token.decimals();\n            }\n        }\n\n        return(totalTokensSold);\n    }\n\n    function isWhitelisted()\n        external\n        view\n        returns (\n            bool\n        )\n    {\n        return (Whitelist[msg.sender].userAddress == msg.sender);\n    }\n\n    function getVestingInfo()\n        external\n        view\n        returns (uint256[] memory, uint256[] memory)\n    {\n        return (vestingPortionsUnlockTime, vestingPercentPerPortion);\n    }\n\n    function calculateAmountWithdrawing(address userAddress, uint256 tokenPercent) internal view returns (\n            uint256\n        ) {\n        \n        Participation memory p = userToParticipation[userAddress];\n\n        Tier memory t = tierIdToTier[uint(p.tierId)];\n\n        uint256 tokensForUser = 0;\n\n        uint256 tokensPerTier = t.tierWeight*sale.amountOfTokensToSell/totalTierWeight;\n\n        uint256 maximunTokensForUser = tokensPerTier*tokenPercent/t.participants/100;\n\n        uint256 userTokenWish = p.amountPaid/sale.tokenPriceInUSDC * (10**sale.token.decimals())*tokenPercent/100;\n\n        if(maximunTokensForUser >= userTokenWish){\n            tokensForUser = userTokenWish;\n        }else{\n            tokensForUser = maximunTokensForUser;\n        }\n\n        return (tokensForUser);\n    }\n\n    function calculateAmountWithdrawingPortionPub(address userAddress, uint256 tokenPercent) public view returns (\n            uint256\n        ) {\n        \n        Participation memory p = userToParticipation[userAddress];\n\n        Tier memory t = tierIdToTier[uint(p.tierId)];\n\n        uint256 tokensPerTier = t.tierWeight * sale.amountOfTokensToSell/totalTierWeight;\n\n        uint256 tokensForUser = tokensPerTier*tokenPercent/t.participants/100;\n\n        return (tokensForUser);\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/ISalesFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISalesFactory {\n    function setSaleOwnerAndToken(address saleOwner, address saleToken) external;\n    function isSaleCreatedThroughFactory(address sale) external view returns (bool);\n}"
    },
    "contracts/IAllocationStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAllocationStaking {\n    function deposited(address _user) external view returns (uint256);\n}"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/SalesFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./BttcPadSale.sol\";\n\ncontract SalesFactory {\n\n    address public allocationStaking;\n    address public admin;\n\n    mapping (address => bool) public isSaleCreatedThroughFactory;\n\n    address [] public allSales;\n\n    modifier onlyAdmin() {\n        require(\n            msg.sender == admin ,\n            \"Only admin can call this function.\"\n        );\n        _;\n    }\n\n    constructor (address _adminAddress, address _allocationStaking)  {\n        require(_adminAddress != address(0), \"error admin\");\n        require(_allocationStaking != address(0), \"error staking\");\n        admin = _adminAddress;\n        allocationStaking = _allocationStaking;\n    }\n\n    function setAllocationStaking(address _allocationStaking) public onlyAdmin {\n        require(_allocationStaking != address(0), \"address error\");\n        allocationStaking = _allocationStaking;\n    }\n\n\n    function deploySale()\n    external\n    onlyAdmin\n    {\n        BttcPadSale sale = new BttcPadSale(address(admin), allocationStaking);\n\n        isSaleCreatedThroughFactory[address(sale)] = true;\n        allSales.push(address(sale));\n    }\n\n    function getNumberOfSalesDeployed() external view returns (uint) {\n        return allSales.length;\n    }\n\n    function getLastDeployedSale() external view returns (address) {\n        //\n        if(allSales.length > 0) {\n            return allSales[allSales.length - 1];\n        }\n        return address(0);\n    }\n\n\n    function getAllSales(uint startIndex, uint endIndex) external view returns (address[] memory) {\n        require(endIndex > startIndex, \"Bad input\");\n        require(endIndex <= allSales.length, \"Request more sale than created\");\n\n        address[] memory sales = new address[](endIndex - startIndex);\n        uint index = 0;\n\n        for(uint i = startIndex; i < endIndex; i++) {\n            sales[index] = allSales[i];\n            index++;\n        }\n\n        return sales;\n    }\n\n}"
    },
    "contracts/Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract AllocationStaking {\n\n    using SafeERC20 for IERC20;\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount;     // How many LP tokens the user has provided.\n        uint256 stakingStart;\n    }\n\n    uint256 internal secondsPerDay = 86400;\n    uint256 public stakingPercent = 20;\n    uint256 public secondsPreYear = 31556926;\n\n    IERC20 stakingToken;\n\n\n    address admin;\n    // The total amount of ERC20 that's paid out as reward.\n    uint256 public paidOut;\n    // Total rewards added to farm\n    uint256 public totalRewards;\n    // Info of each user that stakes LP tokens.\n    mapping (address => UserInfo) public userInfo;\n\n    //Total token deposited\n    uint256 public totalDeposits;\n\n\n    modifier onlyOwner {\n        require( admin == msg.sender , \"Sale not created through factory.\");\n        _;\n    }\n\n    constructor ()  {\n        admin = msg.sender;\n     }\n\n    function setStakingToken(\n        IERC20 _erc20\n    )\n    public onlyOwner\n    {\n        stakingToken = _erc20;\n    }\n\n    function fund(uint256 _amount) public onlyOwner {\n        stakingToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n        totalRewards = totalRewards+_amount;\n    }\n\n    function withdraw(uint256 _amount) public{\n        UserInfo storage user = userInfo[msg.sender];\n        require( user.amount >= _amount, \"Not enough balance\" );\n\n\n        uint256 withdrawFee = getFeeInternal(_amount, user.stakingStart);\n        uint256 tokenToWithdraw = _amount-withdrawFee;       \n\n        harvest();\n        totalRewards = totalRewards+withdrawFee;\n\n        user.stakingStart = block.timestamp;\n        user.amount = user.amount-_amount;\n\n        totalDeposits = totalDeposits-_amount;\n        stakingToken.safeTransfer(address(msg.sender), tokenToWithdraw);\n    }\n\n    function deposit(uint256 _amount) public {\n        UserInfo storage user = userInfo[msg.sender];\n\n        // Harvest user pending tokens\n        if ( user.amount != 0 ){\n            harvest();\n        }\n\n        stakingToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n        totalDeposits = totalDeposits+_amount;\n\n        user.amount = user.amount+_amount;\n        user.stakingStart = block.timestamp;\n    }\n\n    function deposited(address _user) public view returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        return user.amount;\n    }\n\n    function pending() public view returns(uint256){\n       UserInfo memory user = userInfo[msg.sender];\n       uint256 pendingTokens = pendingAmountInternal(user.stakingStart, user.amount);\n       return(pendingTokens);\n    }\n\n    function harvest() internal{\n        UserInfo storage user = userInfo[msg.sender];\n\n        uint256 userPendingEarns = pending();\n\n        require( userPendingEarns <= totalRewards, \"Not enough token\" );\n\n        stakingToken.safeTransfer(address(msg.sender), userPendingEarns);\n        user.stakingStart = block.timestamp;\n        totalRewards = totalRewards - userPendingEarns;\n        paidOut = paidOut + userPendingEarns;\n    }\n   \n\n    function getWithdrawFee(address userAddress, uint256 amountToWithdraw) external view returns (uint256) {\n        UserInfo storage user = userInfo[userAddress];\n\n        return getFeeInternal(amountToWithdraw, user.stakingStart);\n    }\n\n    function getFeeInternal( uint256 amount, uint256 stakingStart )  public view returns(uint256){\n        \n        uint256 withdrawFeePercent = getUnstakePercent(block.timestamp-stakingStart);\n        \n        return(amount*withdrawFeePercent/100);\n    }\n\n\n    function pendingAmountInternal(uint256 _stakingStart, uint256 _amount) internal view returns(uint256){\n        uint256 currenntTimestamp = block.timestamp;\n        uint256 stakingDuration = currenntTimestamp-_stakingStart;\n\n        uint256 pendingTokens = _amount*stakingDuration*stakingPercent/100/secondsPreYear;\n\n        return (pendingTokens);\n    }\n\n    function getUnstakePercent(uint256 stakingTime) internal view returns (uint256){\n        uint256 unstakePercent = 0;\n        if ( stakingTime < secondsPerDay*14 ){\n            unstakePercent = 30;\n        } else if ( stakingTime < secondsPerDay*28 ){\n            unstakePercent = 20;\n        } else if ( stakingTime < secondsPerDay*42 ){\n            unstakePercent = 10;\n        } else if ( stakingTime < secondsPerDay*56 ){\n            unstakePercent = 5;\n        }\n        return (unstakePercent);\n    }\n\n}"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}